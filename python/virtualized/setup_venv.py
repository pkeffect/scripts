"""
VEnvWiz: Virtual Environment Wizard
===================================

A beautiful, feature-rich tool for creating and managing Python virtual environments.

Features:
- User-friendly colored interface with emoji support
- Python version detection and selection
- Cross-platform support (Windows, macOS, Linux)
- Templated requirements.txt creation
- Package installation
- Comprehensive activation instructions
- IDE integration options

Author: Enhanced from original script
Version: 2.1.0
License: MIT
"""

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any

# Set version
__version__ = "2.1.0"

# Try to import colorama for cross-platform color support
try:
    from colorama import Fore, Back, Style, init
    has_colorama = True
    init(autoreset=True)
except ImportError:
    has_colorama = False
    # Create mock colorama classes if not available
    class MockStyle:
        NORMAL = BRIGHT = RESET_ALL = ""
    class MockFore:
        BLACK = RED = GREEN = YELLOW = BLUE = MAGENTA = CYAN = WHITE = ""
        # Add light variants for better dark background visibility
        LIGHTRED = LIGHTGREEN = LIGHTYELLOW = LIGHTBLUE = LIGHTMAGENTA = LIGHTCYAN = LIGHTWHITE = ""
    class MockBack:
        BLACK = RED = GREEN = YELLOW = BLUE = MAGENTA = CYAN = WHITE = ""
    Fore = MockFore()
    Back = MockBack()
    Style = MockStyle()

# Define emoji constants with better spacing
class Emoji:
    """Emoji constants for better UI"""
    PYTHON = "ðŸ "  # Added space after emoji
    WRENCH = "ðŸ› ï¸ "
    CHECK = "âœ“ "    # Changed to simpler check mark with space
    ERROR = "âœ— "    # Changed to simpler X mark with space
    WARNING = "âš ï¸ "
    FOLDER = "ðŸ“ "
    DELETE = "ðŸ—‘ï¸ "
    SKIP = "â­ï¸ "
    ROCKET = "ðŸš€ "
    NOTE = "ðŸ“ "
    PARTY = "ðŸŽ‰ "
    QUESTION = "â“ "
    EXIT = "ðŸšª "
    GEAR = "âš™ï¸ "
    PACKAGE = "ðŸ“¦ "
    SEARCH = "ðŸ” "
    SAVE = "ðŸ’¾ "
    STAR = "â­ "
    NONE = ""      # For when no emoji is needed but alignment is

# Default requirements templates
BASIC_TEMPLATE = """# Basic Python Project Requirements
# Generated by VEnvWiz v{version}

# Development tools
pytest>=7.0.0
black>=23.0.0
flake8>=6.0.0
"""

WEB_TEMPLATE = """# Web Development Requirements
# Generated by VEnvWiz v{version}

# Web framework
flask>=2.2.0
requests>=2.28.0

# WSGI server
gunicorn>=20.1.0

# Development tools
pytest>=7.0.0
black>=23.0.0
"""

DATA_TEMPLATE = """# Data Science Requirements
# Generated by VEnvWiz v{version}

# Core data libraries
numpy>=1.22.0
pandas>=1.4.0
matplotlib>=3.5.0
seaborn>=0.11.2

# Jupyter
jupyter>=1.0.0
ipykernel>=6.9.0
"""

TEMPLATES = {
    "basic": BASIC_TEMPLATE,
    "web": WEB_TEMPLATE,
    "data": DATA_TEMPLATE,
}

# Color schemes - optimized for both light and dark terminals
class ColorScheme:
    """Color schemes for light and dark terminals"""
    # Standard colors
    PRIMARY = Fore.BLUE       # Primary text color
    SUCCESS = Fore.GREEN      # Success messages
    ERROR = Fore.RED          # Error messages
    WARNING = Fore.YELLOW     # Warning messages
    INFO = Fore.CYAN          # Informational messages
    PROMPT = Fore.CYAN        # Input prompts
    ACCENT = Fore.MAGENTA     # Accent color

    # Better colors for dark terminals (brighter)
    DARK_BG_PRIMARY = Fore.LIGHTBLUE if hasattr(Fore, 'LIGHTBLUE') else Fore.BLUE
    DARK_BG_SUCCESS = Fore.LIGHTGREEN if hasattr(Fore, 'LIGHTGREEN') else Fore.GREEN
    DARK_BG_ERROR = Fore.LIGHTRED if hasattr(Fore, 'LIGHTRED') else Fore.RED
    DARK_BG_WARNING = Fore.LIGHTYELLOW if hasattr(Fore, 'LIGHTYELLOW') else Fore.YELLOW
    DARK_BG_INFO = Fore.LIGHTCYAN if hasattr(Fore, 'LIGHTCYAN') else Fore.CYAN

    # Headers
    HEADER_BG = Back.BLUE
    HEADER_FG = Fore.WHITE

    @staticmethod
    def get_color(color_type: str, dark_bg: bool = True):
        """Get the appropriate color for the terminal background"""
        if not dark_bg:
            return getattr(ColorScheme, color_type)

        dark_attr = f"DARK_BG_{color_type}"
        if hasattr(ColorScheme, dark_attr):
            return getattr(ColorScheme, dark_attr)
        return getattr(ColorScheme, color_type)

class VEnvWizard:
    """Main class for the Virtual Environment Wizard"""

    def __init__(self, args: argparse.Namespace):
        """Initialize with command line arguments"""
        self.args = args

        # Configure UI settings
        self.use_colors = has_colorama and not args.no_color
        self.use_emojis = not args.no_emoji
        self.dark_bg = not args.light_bg  # Default to dark background

        # Set consistent indentation amounts
        self.INDENT_SIZE = 2  # Spaces per indent level
        self.EMOJI_WIDTH = 2  # Visual width of emoji

        # Initialize state variables
        self.venv_name = None
        self.python_cmd = None
        self.python_version = None
        self.requirements_file = None

    def format_text(self, text: str,
                   color_type: str = "PRIMARY",
                   style: str = Style.NORMAL,
                   emoji: str = None,
                   indent: int = 0,
                   align_emoji: bool = True) -> str:
        """Format text with color, style, emoji and indentation"""
        # Apply styling conditionally based on preferences
        c_color = ColorScheme.get_color(color_type, self.dark_bg) if self.use_colors else ""
        c_style = style if self.use_colors else ""

        # Create properly indented and aligned text
        indent_str = " " * (self.INDENT_SIZE * indent)

        # Handle emoji alignment
        if self.use_emojis and emoji:
            emoji_str = emoji
        elif align_emoji and self.use_emojis:
            # Add space for alignment when no emoji but alignment wanted
            emoji_str = " " * self.EMOJI_WIDTH
        else:
            emoji_str = ""

        formatted_text = f"{c_style}{c_color}{indent_str}{emoji_str}{text}{Style.RESET_ALL if self.use_colors else ''}"
        return formatted_text

    def print(self, text: str,
             color_type: str = "PRIMARY",
             style: str = Style.NORMAL,
             emoji: str = None,
             indent: int = 0,
             align_emoji: bool = True) -> None:
        """Print formatted text"""
        print(self.format_text(text, color_type, style, emoji, indent, align_emoji))

    def header(self, text: str) -> None:
        """Print a formatted header with consistent styling"""
        if self.use_colors:
            # Calculate padding to make header visually centered
            width = len(text) + 4  # Add some padding
            padding = " " * 2  # Fixed padding
            print(f"\n{ColorScheme.HEADER_FG + ColorScheme.HEADER_BG + Style.BRIGHT}{padding}{text}{padding}{Style.RESET_ALL}\n")
        else:
            border = "=" * (len(text) + 4)
            print(f"\n{border}\n  {text}  \n{border}\n")

    def input(self, prompt: str,
             color_type: str = "PROMPT",
             emoji: str = None,
             indent: int = 0,
             align_emoji: bool = True) -> str:
        """Get input with formatted prompt"""
        formatted_prompt = self.format_text(prompt, color_type, Style.NORMAL, emoji, indent, align_emoji)
        return input(formatted_prompt)

    def progress(self, text: str, total: int = 10, seconds: float = 1.0) -> None:
        """Display a progress indicator with consistent styling"""
        if self.args.quiet:
            return

        self.print(f"{text}...", "INFO", emoji=Emoji.GEAR)
        if seconds < 0.01:  # Skip animation for very short operations
            return

        bar_width = 40
        for i in range(total + 1):
            progress = i / total
            bar = "â–ˆ" * int(bar_width * progress)
            spaces = " " * (bar_width - len(bar))

            # Use carriage return to update in place
            if self.use_colors:
                sys.stdout.write(f"\r  {Emoji.NONE if self.use_emojis else ''}{ColorScheme.get_color('INFO', self.dark_bg)}{bar}{spaces} {int(progress * 100):3d}%{Style.RESET_ALL}")
            else:
                sys.stdout.write(f"\r  {Emoji.NONE if self.use_emojis else ''}{bar}{spaces} {int(progress * 100):3d}%")
            sys.stdout.flush()

            time.sleep(seconds / total)

        sys.stdout.write("\r" + " " * (bar_width + 10) + "\r")
        sys.stdout.flush()

    def get_venv_name(self) -> str:
        """Determine the virtual environment name with handling for existing dirs"""
        # If name is provided as arg, use it
        if self.args.name:
            venv_name = self.args.name
        # Otherwise prompt for name
        else:
            venv_name = self.input("Enter venv name (e.g., my_venv): ", emoji=Emoji.FOLDER)
            # Ensure name is provided
            while not venv_name.strip():
                self.print("Venv name cannot be empty. Please provide a name.",
                         "WARNING", emoji=Emoji.WARNING, indent=2)
                venv_name = self.input("Enter venv name (e.g., my_venv): ", emoji=Emoji.FOLDER)

        # Handle existing directory
        if os.path.exists(venv_name):
            # Auto delete if specified
            if self.args.force:
                self.print(f"Directory '{venv_name}' already exists, deleting (--force)",
                         "WARNING", emoji=Emoji.DELETE, indent=2)
                self._delete_directory(venv_name)
            # Otherwise prompt for action
            else:
                self.print(f"Directory '{venv_name}' already exists.",
                         "WARNING", emoji=Emoji.WARNING, indent=2)
                delete_existing = self.input(f"Delete existing '{venv_name}' and create new? (y/N): ",
                                           emoji=Emoji.QUESTION, indent=4)

                if delete_existing.lower() == 'y':
                    self._delete_directory(venv_name)
                else:
                    self.print("Please choose a different name.", "WARNING", indent=4)
                    return self.get_venv_name()  # Recursively prompt for new name

        self.venv_name = venv_name
        return venv_name

    def _delete_directory(self, path: str) -> None:
        """Safely delete directory with feedback"""
        try:
            self.progress(f"Deleting {path}", total=5, seconds=0.5)
            shutil.rmtree(path)
            self.print(f"Successfully deleted '{path}'",
                     "SUCCESS", emoji=Emoji.CHECK, indent=4)
        except OSError as e:
            self.print(f"ERROR: Could not delete directory '{path}'",
                     "ERROR", emoji=Emoji.ERROR, indent=4)
            self.print(f"{e}", "ERROR", indent=6)
            self.print("Ensure no processes are using files in it and you have permissions.",
                     "WARNING", indent=6)
            sys.exit(1)

    def find_available_python_versions(self) -> List[Dict[str, str]]:
        """Search system for available Python versions"""
        self.print("Searching for Python installations...", "INFO", emoji=Emoji.SEARCH)
        available_versions = []
        search_commands = []

        # Platform-specific commands
        if platform.system() == "Windows":
            search_commands = [
                ["py", "--list-paths"],
                ["where", "python"],
                ["where", "python3"]
            ]
        else:  # Unix-like (Linux, macOS)
            search_commands = [
                ["which", "python3"],
                ["which", "python"],
                ["find", "/usr/bin", "-name", "python*", "-type", "f", "-executable"],
                ["find", "/usr/local/bin", "-name", "python*", "-type", "f", "-executable"]
            ]

        # Keep track of found Python paths to avoid duplicates
        seen_paths = set()

        # Try search commands
        for cmd in search_commands:
            try:
                process = subprocess.run(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=False
                )

                if process.returncode == 0:
                    for line in process.stdout.strip().splitlines():
                        # Extract python path based on command
                        python_path = None
                        if cmd[0] == "py" and "--list-paths" in cmd:
                            parts = line.split(':', 1)
                            if len(parts) >= 2:
                                python_path = parts[1].strip()
                        elif cmd[0] in ["where", "which", "find"]:
                            python_path = line.strip()

                        # Validate and add Python path
                        if python_path and python_path not in seen_paths:
                            if os.path.isfile(python_path) and os.access(python_path, os.X_OK):
                                # Get Python version
                                try:
                                    version_process = subprocess.run(
                                        [python_path, "--version"],
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE,
                                        text=True,
                                        check=False
                                    )

                                    output = version_process.stdout or version_process.stderr
                                    if "Python" in output:
                                        version_str = output.strip().split()[1]
                                        version_name = f"Python {version_str}"

                                        # Skip venv Pythons
                                        if "venv" not in python_path.lower():
                                            available_versions.append({
                                                'path': python_path,
                                                'version': version_str,
                                                'name': version_name
                                            })
                                            seen_paths.add(python_path)
                                except Exception:
                                    # Skip if version check fails
                                    pass
            except Exception:
                # Skip if command fails
                pass

        # Sort by version (newest first)
        available_versions.sort(
            key=lambda x: [int(v) if v.isdigit() else 0 for v in x.get('version', '0').split('.')],
            reverse=True
        )

        return available_versions

    def get_python_version_specifier(self) -> Optional[str]:
        """Prompt for Python version or offer to select from available"""
        version_choice = self.input("Specify Python version? (y/N, or 'list' for versions): ",
                                  emoji=Emoji.PYTHON)

        if version_choice.lower() == 'y':
            return self.input("Enter version specifier (e.g., python3.9, C:\\Python311\\python.exe): ",
                            indent=2)
        elif version_choice.lower() == 'list':
            available_versions = self.find_available_python_versions()

            if not available_versions:
                self.print("No specific Python versions found by system search.",
                         "WARNING", emoji=Emoji.WARNING, indent=2)
                self.print("You can manually enter a specifier or use default Python.",
                         "WARNING", indent=2)
                return None

            # Display available versions
            self.print("\nAvailable Python versions:", "SUCCESS", emoji=Emoji.STAR, indent=2)
            for i, version_info in enumerate(available_versions):
                # Format path to fit terminal better
                path = version_info['path']
                if len(path) > 40:
                    path = "..." + path[-37:]

                self.print(f"{i+1:>2}. {version_info['name']:<12} - {path}",
                         "INFO", indent=4)

            # Let user choose
            while True:
                try:
                    choice = self.input(f"Choose version number (1-{len(available_versions)}, or 0 for default): ",
                                      indent=2)

                    if not choice.strip():
                        return None

                    choice_idx = int(choice) - 1

                    if choice_idx == -1:
                        return None
                    elif 0 <= choice_idx < len(available_versions):
                        return available_versions[choice_idx]['path']
                    else:
                        self.print(f"Invalid choice. Use number from list or 0.",
                                 "WARNING", emoji=Emoji.WARNING, indent=4)
                except ValueError:
                    self.print("Please enter a number.",
                             "WARNING", emoji=Emoji.WARNING, indent=4)

        return None

    def check_python_executable(self, python_version_specifier: Optional[str]) -> str:
        """Determine and validate Python executable"""
        # Check if a path was directly specified
        if python_version_specifier and os.path.isfile(python_version_specifier):
            if not os.access(python_version_specifier, os.X_OK):
                self.print(f"ERROR: Specified Python path '{python_version_specifier}' is not executable.",
                         "ERROR", emoji=Emoji.ERROR, indent=2)
                sys.exit(1)

            self.print(f"Using Python from path: {python_version_specifier}",
                     "SUCCESS", emoji=Emoji.PYTHON, indent=2)

            # Get version information
            try:
                process = subprocess.run(
                    [python_version_specifier, "--version"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=False
                )
                output = process.stdout or process.stderr
                if "Python" in output:
                    self.python_version = output.strip().split()[1]
            except Exception:
                pass

            return python_version_specifier

        # Check if a command/version was specified
        if python_version_specifier:
            try:
                process = subprocess.run(
                    [python_version_specifier, "--version"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=True
                )

                output = process.stdout or process.stderr
                if "Python" in output:
                    self.python_version = output.strip().split()[1]

                self.print(f"Using Python version specifier: {python_version_specifier}",
                         "SUCCESS", emoji=Emoji.PYTHON, indent=2)
                return python_version_specifier
            except (subprocess.CalledProcessError, FileNotFoundError):
                self.print(f"Warning: Specifier '{python_version_specifier}' invalid. Using default search.",
                         "WARNING", emoji=Emoji.WARNING, indent=2)

        # Try common Python commands
        python_commands = ["py", "python3", "python"]
        for cmd in python_commands:
            try:
                process = subprocess.run(
                    [cmd, "--version"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=True
                )

                output = process.stdout or process.stderr
                if "Python" in output:
                    self.python_version = output.strip().split()[1]

                self.print(f"Found Python executable using command: {cmd}",
                         "SUCCESS", emoji=Emoji.PYTHON, indent=2)
                return cmd
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass

        # If we get here, no Python was found
        self.print("ERROR: Could not find Python executable.",
                 "ERROR", emoji=Emoji.ERROR, indent=2)
        self.print("Ensure Python is installed and in your system's PATH.",
                 "ERROR", indent=4)
        sys.exit(1)

    def create_venv(self, python_cmd: str, venv_name: str, python_version_specifier: Optional[str]) -> None:
        """Create virtual environment with specified Python"""
        self.print(f"\nCreating virtual environment '{venv_name}'...",
                 "INFO", emoji=Emoji.WRENCH)

        # Build command
        venv_command = [python_cmd, "-m", "venv"]

        # Add flags
        if self.args.system_site_packages:
            venv_command.append("--system-site-packages")
        if self.args.symlinks:
            venv_command.append("--symlinks")
        if self.args.no_pip:
            venv_command.append("--without-pip")

        # Add Python specifier if needed
        if python_version_specifier and not os.path.isfile(python_version_specifier):
            venv_command.extend(["--python", python_version_specifier])

        # Add target directory
        venv_command.append(venv_name)

        try:
            self.progress("Setting up virtual environment", total=10, seconds=1.5)

            process = subprocess.run(
                venv_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=False
            )

            if process.returncode != 0:
                self.print("ERROR: Failed to create virtual environment.",
                         "ERROR", emoji=Emoji.ERROR, indent=2)
                self.print(f"{process.stderr}", "ERROR", indent=4)
                sys.exit(1)

            self.print(f"Virtual environment '{venv_name}' created successfully!",
                     "SUCCESS", emoji=Emoji.PARTY)

        except Exception as e:
            self.print("ERROR: Failed to create virtual environment.",
                     "ERROR", emoji=Emoji.ERROR, indent=2)
            self.print(f"{e}", "ERROR", indent=4)
            sys.exit(1)

    def create_requirements_file(self, venv_name: str) -> None:
        """Create requirements.txt file"""
        if self.args.no_requirements:
            return

        requirements_file_path = os.path.join(venv_name, "requirements.txt")

        # Determine which template to use
        if self.args.template:
            template_name = self.args.template.lower()
            if template_name in TEMPLATES:
                content = TEMPLATES[template_name].format(version=__version__)
                self.print(f"Using '{template_name}' template for requirements.txt",
                         "SUCCESS", emoji=Emoji.STAR, indent=2)
            else:
                self.print(f"Template '{template_name}' not found, using basic template",
                         "WARNING", emoji=Emoji.WARNING, indent=2)
                content = TEMPLATES["basic"].format(version=__version__)
        else:
            # Prompt for template choice if not quiet or non-interactive
            if not self.args.quiet and not self.args.non_interactive:
                self.print("\nSelect a requirements.txt template:",
                         "INFO", emoji=Emoji.NOTE, indent=2)
                self.print("1. Basic/minimal (default)", "PRIMARY", indent=4)
                self.print("2. Web development", "PRIMARY", indent=4)
                self.print("3. Data science", "PRIMARY", indent=4)

                choice = self.input("Template choice [1-3]: ", indent=2)

                if choice == "2":
                    content = TEMPLATES["web"].format(version=__version__)
                    self.print("Using 'web' template", "SUCCESS", emoji=Emoji.CHECK, indent=4)
                elif choice == "3":
                    content = TEMPLATES["data"].format(version=__version__)
                    self.print("Using 'data' template", "SUCCESS", emoji=Emoji.CHECK, indent=4)
                else:
                    content = TEMPLATES["basic"].format(version=__version__)
                    self.print("Using 'basic' template", "SUCCESS", emoji=Emoji.CHECK, indent=4)
            else:
                content = TEMPLATES["basic"].format(version=__version__)

        try:
            with open(requirements_file_path, 'w') as f:
                f.write(content)
            self.print(f"Created requirements.txt file",
                     "SUCCESS", emoji=Emoji.NOTE, indent=2)
            self.requirements_file = requirements_file_path
        except Exception as e:
            self.print(f"Warning: Could not create requirements.txt file",
                     "WARNING", emoji=Emoji.WARNING, indent=2)
            self.print(f"{e}", "WARNING", indent=4)

    def install_packages(self) -> None:
        """Install packages from requirements.txt"""
        if self.args.no_pip_install or not self.requirements_file or self.args.no_pip:
            return

        # Check if pip install is requested
        if not self.args.pip_install and not self.args.non_interactive:
            install = self.input("Install packages from requirements.txt? [y/N]: ",
                               emoji=Emoji.PACKAGE)
            if install.lower() != 'y':
                return

        # Get pip path
        pip_path = self._get_venv_pip_path()
        if not pip_path:
            self.print("Warning: Could not find pip in virtual environment",
                     "WARNING", emoji=Emoji.WARNING, indent=2)
            return

        self.print("Installing packages from requirements.txt...",
                 "INFO", emoji=Emoji.PACKAGE)

        try:
            self.progress("Installing packages", total=10, seconds=2.0)

            process = subprocess.run(
                [pip_path, "install", "-r", self.requirements_file],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=False
            )

            if process.returncode != 0:
                self.print("Warning: Failed to install some packages",
                         "WARNING", emoji=Emoji.WARNING, indent=2)
                self.print(f"{process.stderr}", "WARNING", indent=4)
                return

            self.print("Packages installed successfully",
                     "SUCCESS", emoji=Emoji.CHECK, indent=2)

        except Exception as e:
            self.print("Warning: Error during package installation",
                     "WARNING", emoji=Emoji.WARNING, indent=2)
            self.print(f"{e}", "WARNING", indent=4)

    def _get_venv_pip_path(self) -> Optional[str]:
        """Get path to pip in virtual environment"""
        if platform.system() == "Windows":
            pip_path = os.path.join(self.venv_name, "Scripts", "pip.exe")
            if not os.path.isfile(pip_path):
                pip_path = os.path.join(self.venv_name, "Scripts", "pip3.exe")
        else:  # Unix-like
            pip_path = os.path.join(self.venv_name, "bin", "pip")
            if not os.path.isfile(pip_path):
                pip_path = os.path.join(self.venv_name, "bin", "pip3")

        if os.path.isfile(pip_path) and os.access(pip_path, os.X_OK):
            return pip_path

        return None

    def print_activation_instructions(self, venv_name: str) -> None:
        """Print activation/deactivation instructions with clear formatting"""
        venv_path = os.path.abspath(venv_name)

        self.print("\nVirtual Environment Activation Instructions:",
                 "INFO", emoji=Emoji.ROCKET)

        # Create a formatted table-like display for commands
        def print_command_row(platform, command):
            self.print(f"{platform}:", "ACCENT", indent=2)
            self.print(f"{command}", "PRIMARY", indent=4)

        # Windows instructions
        if platform.system() == "Windows":
            act_script = os.path.join(venv_name, "Scripts", "activate.bat")
            print_command_row("Windows Command Prompt", act_script)

            # PowerShell
            ps_activate = os.path.join(venv_name, "Scripts", "Activate.ps1")
            print_command_row("Windows PowerShell", f".\\{venv_name}\\Scripts\\Activate.ps1")
        # Unix-like instructions
        else:
            act_script = os.path.join(venv_name, "bin", "activate")
            print_command_row("Linux/macOS (Bash/Zsh)", f"source {act_script}")

        # Deactivation (same for all platforms)
        self.print("\nTo deactivate the environment:", "ERROR", indent=2)
        self.print("deactivate", "PRIMARY", indent=4)

        # IDE integration tips with better formatting
        self.print("\nIDE Integration:", "ACCENT", emoji=Emoji.GEAR, indent=2)

        # Format as a clean two-column display with proper alignment
        ide_instructions = [
            ("VS Code:", "Select interpreter via Command Palette (Ctrl+Shift+P)"),
            ("PyCharm:", "Set as project interpreter in Settings > Project > Python Interpreter"),
            ("Jupyter:", "Select kernel from the running environment")
        ]

        for ide, instruction in ide_instructions:
            self.print(f"{ide:<10} {instruction}", "PRIMARY", indent=4)

        # Package management with better formatting
        self.print("\nPackage Management:", "SUCCESS", emoji=Emoji.PACKAGE, indent=2)

        pkg_commands = [
            ("Install:", "pip install <package-name>"),
            ("Save deps:", "pip freeze > requirements.txt"),
            ("Update:", "pip install -U <package-name>")
        ]

        for action, command in pkg_commands:
            self.print(f"{action:<10} {command}", "PRIMARY", indent=4)

    def run(self) -> None:
        """Main execution flow"""
        try:
            # Display banner
            self.header(f"Virtual Environment Wizard v{__version__}")

            # Get environment name
            venv_name = self.get_venv_name()

            # Get Python version specifier
            python_version_specifier = self.get_python_version_specifier()

            # Get Python executable
            python_cmd = self.check_python_executable(python_version_specifier)

            # Create virtual environment
            self.create_venv(python_cmd, venv_name, python_version_specifier)

            # Create requirements.txt file
            self.create_requirements_file(venv_name)

            # Install packages if requested
            self.install_packages()

            # Print activation instructions
            self.print_activation_instructions(venv_name)

            # Final success message
            self.header(f"Virtual environment '{venv_name}' setup complete!")
            # Add one final emoji line for flair
            if self.use_emojis:
                padding = " " * 20
                print(f"\n{padding}{Emoji.PARTY} {Emoji.PYTHON} {Emoji.PARTY}\n")

        except KeyboardInterrupt:
            self.print("\nOperation canceled by user", "WARNING", emoji=Emoji.EXIT)
            sys.exit(0)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description=f"VEnvWiz v{__version__}: Virtual Environment Wizard",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    # Basic options
    basic_group = parser.add_argument_group("Basic Options")
    basic_group.add_argument("-n", "--name",
                        help="Name of virtual environment to create")
    basic_group.add_argument("-p", "--python",
                        help="Python executable to use (path or command)")

    # Venv options
    venv_group = parser.add_argument_group("Virtual Environment Options")
    venv_group.add_argument("-s", "--system-site-packages", action="store_true",
                        help="Give venv access to system site-packages")
    venv_group.add_argument("--symlinks", action="store_true",
                        help="Use symlinks instead of copies (Unix only)")
    venv_group.add_argument("--no-pip", action="store_true",
                        help="Skip pip installation in virtual environment")

    # Requirements options
    req_group = parser.add_argument_group("Requirements Options")
    req_group.add_argument("--no-requirements", action="store_true",
                        help="Don't create requirements.txt file")
    req_group.add_argument("--template", choices=["basic", "web", "data"],
                        help="Requirements template to use")
    req_group.add_argument("--pip-install", action="store_true",
                        help="Install packages from requirements.txt")
    req_group.add_argument("--no-pip-install", action="store_true",
                        help="Don't install packages from requirements.txt")

    # Behavioral options
    behavior_group = parser.add_argument_group("Behavioral Options")
    behavior_group.add_argument("-f", "--force", action="store_true",
                        help="Force creation (delete existing directory)")
    behavior_group.add_argument("--non-interactive", action="store_true",
                        help="Non-interactive mode (use defaults)")

    # UI options
    ui_group = parser.add_argument_group("User Interface Options")
    ui_group.add_argument("-q", "--quiet", action="store_true",
                        help="Minimal output")
    ui_group.add_argument("--no-color", action="store_true",
                        help="Disable colored output")
    ui_group.add_argument("--no-emoji", action="store_true",
                        help="Disable emoji output")
    ui_group.add_argument("--light-bg", action="store_true",
                        help="Optimize colors for light terminal background")

    # Version
    parser.add_argument("--version", action="version",
                      version=f"VEnvWiz v{__version__}")

    return parser.parse_args()


def main() -> None:
    """Main entry point"""
    # Parse arguments
    args = parse_args()

    # Create and run wizard
    wizard = VEnvWizard(args)
    wizard.run()


if __name__ == "__main__":
    main()
