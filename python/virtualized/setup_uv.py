#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
uvWiz: uv Environment Wizard
============================

A beautiful, feature-rich tool for creating and managing uv virtual environments.

Features:
- User-friendly colored interface with emoji support
- Python version selection and detection
- Cross-platform support (Windows, macOS, Linux)
- Templated requirements.txt creation
- Package installation with uv's fast pip
- Comprehensive activation instructions
- IDE integration options
- Git repository support

Author: Enhanced from original script
Version: 2.0.0
License: MIT
"""

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
import time
from pathlib import Path
from typing import Dict, List, Optional, Union

# Set version
__version__ = "2.0.0"

# Try to import colorama for cross-platform color support
try:
    from colorama import Fore, Back, Style, init
    has_colorama = True
    init(autoreset=True)
except ImportError:
    has_colorama = False
    # Create mock colorama classes if not available
    class MockStyle:
        NORMAL = BRIGHT = RESET_ALL = ""
    class MockFore:
        BLACK = RED = GREEN = YELLOW = BLUE = MAGENTA = CYAN = WHITE = ""
    class MockBack:
        BLACK = RED = GREEN = YELLOW = BLUE = MAGENTA = CYAN = WHITE = ""
    Fore = MockFore()
    Back = MockBack()
    Style = MockStyle()

# Define emoji constants
class Emoji:
    """Emoji constants for better UI"""
    PYTHON = "ðŸ"
    UV = "ðŸš€"  # Using rocket for uv (speed)
    WRENCH = "ðŸ› ï¸"
    CHECK = "âœ…"
    ERROR = "âŒ"
    WARNING = "âš ï¸"
    FOLDER = "ðŸ“"
    DELETE = "ðŸ—‘ï¸"
    SKIP = "â­ï¸"
    ROCKET = "ðŸš€"
    NOTE = "ðŸ“"
    PARTY = "ðŸŽ‰"
    QUESTION = "â“"
    EXIT = "ðŸšª"
    GEAR = "âš™ï¸"
    PACKAGE = "ðŸ“¦"
    SEARCH = "ðŸ”"
    SAVE = "ðŸ’¾"
    STAR = "â­"
    BOLT = "âš¡"
    BOOK = "ðŸ“š"

# Default requirements templates
BASIC_TEMPLATE = """# Basic Python Project Requirements
# Generated by uvWiz

# Testing tools
pytest>=7.0.0

# Development tools
black>=23.0.0
flake8>=6.0.0
"""

WEB_TEMPLATE = """# Web Development Requirements
# Generated by uvWiz

# Web framework
flask>=2.2.0
requests>=2.28.0

# WSGI server
gunicorn>=20.1.0

# Development tools
pytest>=7.0.0
black>=23.0.0
"""

DATA_TEMPLATE = """# Data Science Requirements
# Generated by uvWiz

# Core data libraries
numpy>=1.22.0
pandas>=1.4.0
matplotlib>=3.5.0
seaborn>=0.11.2

# Jupyter
jupyter>=1.0.0
ipykernel>=6.9.0
"""

AI_TEMPLATE = """# AI/ML Development Requirements
# Generated by uvWiz

# Core libraries
numpy>=1.22.0
pandas>=1.4.0
scikit-learn>=1.2.0

# Deep learning
torch>=2.0.0
tensorflow>=2.12.0

# Visualization
matplotlib>=3.7.0
seaborn>=0.12.0

# Jupyter
jupyter>=1.0.0
"""

TEMPLATES = {
    "basic": BASIC_TEMPLATE,
    "web": WEB_TEMPLATE,
    "data": DATA_TEMPLATE,
    "ai": AI_TEMPLATE,
}


class UVWizard:
    """Main class for the uv Environment Wizard"""
    
    def __init__(self, args: argparse.Namespace):
        """Initialize with command line arguments"""
        self.args = args
        
        # Configure UI settings
        self.use_colors = has_colorama and not args.no_color
        self.use_emojis = not args.no_emoji
        self.quiet = args.quiet
        
        # Initialize state variables
        self.venv_name = None
        self.uv_exe = args.uv_exe if args.uv_exe else "uv"
        self.python_version = None
        self.python_path = None
        self.requirements_file = None
    
    def format_text(self, text: str, 
                   color: str = Fore.WHITE, 
                   style: str = Style.NORMAL, 
                   emoji: str = None,
                   indent: int = 0) -> str:
        """Format text with color, style, emoji and indentation"""
        # Apply styling conditionally based on preferences
        c_color = color if self.use_colors else ""
        c_style = style if self.use_colors else ""
        c_emoji = f"{emoji} " if emoji and self.use_emojis else ""
        c_indent = " " * indent
        
        return f"{c_style}{c_color}{c_indent}{c_emoji}{text}{Style.RESET_ALL if self.use_colors else ''}"
    
    def print(self, text: str, 
             color: str = Fore.WHITE, 
             style: str = Style.NORMAL, 
             emoji: str = None,
             indent: int = 0) -> None:
        """Print formatted text if not in quiet mode"""
        if not self.quiet:
            print(self.format_text(text, color, style, emoji, indent))
    
    def header(self, text: str, bg_color: str = Back.BLUE) -> None:
        """Print a formatted header"""
        if not self.quiet:
            if self.use_colors:
                print(f"\n{Fore.WHITE + bg_color + Style.BRIGHT}  {text}  {Style.RESET_ALL}\n")
            else:
                print(f"\n--- {text} ---\n")
    
    def input(self, prompt: str, 
             color: str = Fore.CYAN, 
             emoji: str = None,
             indent: int = 0) -> str:
        """Get input with formatted prompt"""
        formatted_prompt = self.format_text(prompt, color, Style.NORMAL, emoji, indent)
        return input(formatted_prompt)
    
    def progress(self, text: str, total: int = 10, seconds: float = 1.0) -> None:
        """Display a progress indicator"""
        if self.quiet:
            return
            
        self.print(f"{text}...", Fore.YELLOW, emoji=Emoji.GEAR)
        if seconds < 0.01:  # Skip animation for very short operations
            return
            
        bar_width = 40
        for i in range(total + 1):
            progress = i / total
            bar = "â–ˆ" * int(bar_width * progress)
            spaces = " " * (bar_width - len(bar))
            
            # Use carriage return to update in place
            if self.use_colors:
                sys.stdout.write(f"\r{Fore.YELLOW}  {bar}{spaces} {int(progress * 100):3d}%")
            else:
                sys.stdout.write(f"\r  {bar}{spaces} {int(progress * 100):3d}%")
            sys.stdout.flush()
            
            time.sleep(seconds / total)
        
        sys.stdout.write("\r" + " " * (bar_width + 10) + "\r")
        sys.stdout.flush()
    
    def check_uv_installation(self) -> bool:
        """Check if uv is installed and available"""
        try:
            process = subprocess.run(
                [self.uv_exe, "--version"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=False
            )
            
            if process.returncode == 0:
                version = process.stdout.strip()
                self.print(f"uv is installed: {version}", 
                         Fore.GREEN, emoji=Emoji.CHECK, indent=2)
                return True
            else:
                self.print("ERROR: uv is not functioning correctly", 
                         Fore.RED, emoji=Emoji.ERROR, indent=2)
                self.print(f"Error message: {process.stderr}", 
                         Fore.RED, indent=4)
                return False
        except FileNotFoundError:
            self.print(f"ERROR: uv executable '{self.uv_exe}' not found", 
                     Fore.RED, emoji=Emoji.ERROR, indent=2)
            self.print("Make sure uv is installed and in your PATH", 
                     Fore.YELLOW, indent=4)
            self.print("Or specify the uv executable with --uv-exe", 
                     Fore.YELLOW, indent=4)
            return False
    
    def get_venv_name(self) -> str:
        """Determine the virtual environment name and check if it exists"""
        # If name is provided as arg, use it
        if self.args.name:
            venv_name = self.args.name
        # Otherwise prompt for name
        else:
            venv_name = self.input("Enter uv environment name (e.g., my_env): ", 
                                  emoji=Emoji.FOLDER)
            # Ensure name is provided
            while not venv_name.strip():
                self.print("Environment name cannot be empty. Please provide a name.",
                         Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
                venv_name = self.input("Enter uv environment name (e.g., my_env): ", 
                                      emoji=Emoji.FOLDER)
        
        # Check if environment already exists
        if os.path.exists(venv_name):
            # Auto delete if specified
            if self.args.force:
                self.print(f"Directory '{venv_name}' already exists, deleting (--force)", 
                         Fore.YELLOW, emoji=Emoji.DELETE, indent=2)
                self._delete_directory(venv_name)
            # Otherwise prompt for action
            else:
                self.print(f"Directory '{venv_name}' already exists.", 
                         Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
                delete_existing = self.input(f"Delete existing '{venv_name}' and create new? (y/N): ",
                                           emoji=Emoji.QUESTION, indent=4)
                
                if delete_existing.lower() == 'y':
                    self._delete_directory(venv_name)
                else:
                    self.print("Please choose a different name.", 
                             Fore.YELLOW, indent=4)
                    return self.get_venv_name()  # Recursively prompt for new name
        
        self.venv_name = venv_name
        return venv_name
    
    def _delete_directory(self, path: str) -> None:
        """Safely delete directory with feedback"""
        try:
            self.progress(f"Deleting {path}", total=5, seconds=0.5)
            shutil.rmtree(path)
            self.print(f"Successfully deleted '{path}'", 
                     Fore.GREEN, emoji=Emoji.CHECK, indent=4)
        except OSError as e:
            self.print(f"ERROR: Could not delete directory '{path}'", 
                     Fore.RED, emoji=Emoji.ERROR, indent=4)
            self.print(f"{e}", Fore.RED, indent=6)
            self.print("Ensure no processes are using files in it and you have permissions.", 
                     Fore.YELLOW, indent=6)
            sys.exit(1)
    
    def find_available_python_versions(self) -> List[Dict[str, str]]:
        """Search system for available Python versions"""
        self.print("Searching for Python installations...", 
                 Fore.CYAN, emoji=Emoji.SEARCH)
        available_versions = []
        search_commands = []
        
        # Platform-specific commands
        if platform.system() == "Windows":
            search_commands = [
                ["py", "--list-paths"],
                ["where", "python"],
                ["where", "python3"]
            ]
        else:  # Unix-like (Linux, macOS)
            search_commands = [
                ["which", "python3"],
                ["which", "python"],
                ["find", "/usr/bin", "-name", "python*", "-type", "f", "-executable"],
                ["find", "/usr/local/bin", "-name", "python*", "-type", "f", "-executable"]
            ]
        
        # Keep track of found Python paths to avoid duplicates
        seen_paths = set()
        
        # Try search commands
        for cmd in search_commands:
            try:
                process = subprocess.run(
                    cmd, 
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.PIPE,
                    text=True,
                    check=False
                )
                
                if process.returncode == 0:
                    for line in process.stdout.strip().splitlines():
                        # Extract python path based on command
                        python_path = None
                        if cmd[0] == "py" and "--list-paths" in cmd:
                            parts = line.split(':', 1)
                            if len(parts) >= 2:
                                python_path = parts[1].strip()
                        elif cmd[0] in ["where", "which", "find"]:
                            python_path = line.strip()
                        
                        # Validate and add Python path
                        if python_path and python_path not in seen_paths:
                            if os.path.isfile(python_path) and os.access(python_path, os.X_OK):
                                # Get Python version
                                try:
                                    version_process = subprocess.run(
                                        [python_path, "--version"],
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE,
                                        text=True,
                                        check=False
                                    )
                                    
                                    output = version_process.stdout or version_process.stderr
                                    if "Python" in output:
                                        version_str = output.strip().split()[1]
                                        version_name = f"Python {version_str}"
                                        
                                        # Skip venv Pythons
                                        if "venv" not in python_path.lower():
                                            available_versions.append({
                                                'path': python_path,
                                                'version': version_str,
                                                'name': version_name
                                            })
                                            seen_paths.add(python_path)
                                except Exception:
                                    # Skip if version check fails
                                    pass
            except Exception:
                # Skip if command fails
                pass
        
        # Sort by version (newest first)
        available_versions.sort(
            key=lambda x: [int(v) if v.isdigit() else 0 for v in x.get('version', '0').split('.')],
            reverse=True
        )
        
        return available_versions
    
    def get_python_version(self) -> Optional[str]:
        """Select Python version/path for the environment"""
        # Check if version specified in args
        if self.args.python:
            self.print(f"Using specified Python: {self.args.python}", 
                     Fore.GREEN, emoji=Emoji.PYTHON, indent=2)
            self.python_path = self.args.python
            return self.args.python
        
        # Check if non-interactive mode
        if self.args.non_interactive:
            self.print("Using system Python (non-interactive mode)", 
                     Fore.GREEN, emoji=Emoji.PYTHON, indent=2)
            return None  # Use system Python in non-interactive mode
        
        # Interactive mode - ask for version
        version_choice = self.input("Specify Python version? (y/N, or 'list' for versions): ", 
                                  emoji=Emoji.PYTHON)
        
        if version_choice.lower() == 'y':
            path = self.input("Enter Python path or command (e.g., python3.9, /usr/bin/python3): ", 
                            indent=2)
            self.python_path = path
            return path
        elif version_choice.lower() == 'list':
            versions = self.find_available_python_versions()
            
            if not versions:
                self.print("No Python versions found. Using system Python.", 
                         Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
                return None
            
            # Display available versions
            self.print("\nAvailable Python versions:", 
                     Fore.GREEN, emoji=Emoji.STAR, indent=2)
            for i, version_info in enumerate(versions):
                self.print(f"{i+1:>2}. {version_info['name']:<12} - {version_info['path']}", 
                         Fore.CYAN, indent=4)
            
            # Let user choose
            while True:
                try:
                    choice = self.input(f"Choose version number (1-{len(versions)}, or Enter for system Python): ", 
                                      indent=2)
                    
                    if not choice.strip():
                        self.print("Using system Python", 
                                 Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                        return None  # Use system Python
                    
                    choice_idx = int(choice) - 1
                    if 0 <= choice_idx < len(versions):
                        path = versions[choice_idx]['path']
                        self.python_path = path
                        self.print(f"Using Python: {path}", 
                                 Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                        return path
                    else:
                        self.print(f"Invalid choice. Please enter 1-{len(versions)}", 
                                 Fore.YELLOW, emoji=Emoji.WARNING, indent=4)
                except ValueError:
                    self.print("Please enter a number", 
                             Fore.YELLOW, emoji=Emoji.WARNING, indent=4)
        
        self.print("Using system Python", 
                 Fore.GREEN, emoji=Emoji.CHECK, indent=2)
        return None  # Use system Python by default
    
    def create_venv(self, python_version: Optional[str]) -> bool:
        """Create the uv virtual environment"""
        env_name = self.venv_name
        
        self.print(f"\nCreating uv virtual environment '{env_name}'...", 
                 Fore.CYAN, emoji=Emoji.WRENCH)
        
        # Prepare uv create command
        create_cmd = [self.uv_exe, "venv", env_name]
        
        # Add Python specifier if provided
        if python_version:
            create_cmd.extend(["--python", python_version])
        
        # Add extra flags if specified
        if self.args.system_site_packages:
            create_cmd.append("--system-site-packages")
        
        try:
            self.progress("Setting up virtual environment", total=10, seconds=1.5)
            
            process = subprocess.run(
                create_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=False
            )
            
            if process.returncode != 0:
                self.print("ERROR: Failed to create uv virtual environment", 
                         Fore.RED, emoji=Emoji.ERROR, indent=2)
                self.print(f"{process.stderr}", Fore.RED, indent=4)
                return False
            
            self.print(f"uv virtual environment '{env_name}' created successfully!", 
                     Fore.GREEN, emoji=Emoji.PARTY)
            return True
            
        except Exception as e:
            self.print("ERROR: Failed to create uv virtual environment", 
                     Fore.RED, emoji=Emoji.ERROR, indent=2)
            self.print(f"{e}", Fore.RED, indent=4)
            return False
    
    def create_requirements_file(self) -> None:
        """Create requirements.txt file"""
        if self.args.no_requirements:
            return
            
        env_name = self.venv_name
        os.makedirs(env_name, exist_ok=True)  # Ensure directory exists
        requirements_file_path = os.path.join(env_name, "requirements.txt")
        
        # Determine which template to use
        if self.args.template:
            template_name = self.args.template.lower()
            if template_name in TEMPLATES:
                content = TEMPLATES[template_name]
                self.print(f"Using '{template_name}' template for requirements.txt", 
                         Fore.GREEN, emoji=Emoji.STAR, indent=2)
            else:
                self.print(f"Template '{template_name}' not found, using basic template", 
                         Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
                content = TEMPLATES["basic"]
        else:
            # Prompt for template choice if not quiet or non-interactive
            if not self.args.non_interactive:
                self.print("\nSelect a requirements.txt template:", 
                         Fore.CYAN, emoji=Emoji.NOTE, indent=2)
                self.print("1. Basic/minimal (default)", Fore.WHITE, indent=4)
                self.print("2. Web development", Fore.WHITE, indent=4)
                self.print("3. Data science", Fore.WHITE, indent=4)
                self.print("4. AI/ML development", Fore.WHITE, indent=4)
                
                choice = self.input("Template choice [1-4]: ", indent=2)
                
                if choice == "2":
                    content = TEMPLATES["web"]
                    self.print("Using 'web' template", 
                             Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                elif choice == "3":
                    content = TEMPLATES["data"]
                    self.print("Using 'data' template", 
                             Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                elif choice == "4":
                    content = TEMPLATES["ai"]
                    self.print("Using 'ai' template", 
                             Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                else:
                    content = TEMPLATES["basic"]
                    self.print("Using 'basic' template", 
                             Fore.GREEN, emoji=Emoji.CHECK, indent=4)
            else:
                content = TEMPLATES["basic"]
        
        try:
            with open(requirements_file_path, 'w') as f:
                f.write(content)
            self.print(f"Created requirements.txt file", 
                     Fore.GREEN, emoji=Emoji.NOTE, indent=2)
            self.requirements_file = requirements_file_path
        except Exception as e:
            self.print(f"Warning: Could not create requirements.txt file", 
                     Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
            self.print(f"{e}", Fore.YELLOW, indent=4)
    
    def install_packages(self) -> None:
        """Install packages from requirements.txt using uv pip"""
        if self.args.no_pip_install or not self.requirements_file:
            return
            
        # Check if pip install is requested
        if not self.args.pip_install and not self.args.non_interactive:
            install = self.input("Install packages from requirements.txt? [y/N]: ", 
                               emoji=Emoji.PACKAGE)
            if install.lower() != 'y':
                return
        
        env_name = self.venv_name
        
        self.print("Installing packages from requirements.txt...", 
                 Fore.CYAN, emoji=Emoji.PACKAGE)
        
        try:
            self.progress("Installing packages", total=10, seconds=2.0)
            
            # Determine python path in environment
            if platform.system() == "Windows":
                python_path = os.path.join(env_name, "Scripts", "python.exe")
            else:
                python_path = os.path.join(env_name, "bin", "python")
            
            # Use uv pip install command
            install_cmd = [
                self.uv_exe, "pip", "install", 
                "--python", python_path,
                "--requirement", self.requirements_file
            ]
            
            process = subprocess.run(
                install_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                check=False
            )
            
            if process.returncode != 0:
                self.print("Warning: Failed to install some packages", 
                         Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
                self.print(f"{process.stderr}", Fore.YELLOW, indent=4)
                return
            
            self.print("Packages installed successfully", 
                     Fore.GREEN, emoji=Emoji.CHECK, indent=2)
            
        except Exception as e:
            self.print("Warning: Error during package installation", 
                     Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
            self.print(f"{e}", Fore.YELLOW, indent=4)
    
    def create_gitignore(self) -> None:
        """Generate .gitignore file for the project"""
        if not self.args.gitignore:
            return
            
        venv_path = self.venv_name
        gitignore_path = ".gitignore"
        
        # Check if file already exists
        if os.path.exists(gitignore_path):
            self.print(f".gitignore already exists, checking for venv entry", 
                     Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
            
            # Check if venv is already in gitignore
            with open(gitignore_path, 'r') as f:
                content = f.read()
            
            venv_pattern = f"{venv_path}/"
            if venv_pattern in content:
                self.print(f"Entry for '{venv_path}' already in .gitignore", 
                         Fore.GREEN, emoji=Emoji.CHECK, indent=4)
                return
            
            # Append to file
            with open(gitignore_path, 'a') as f:
                f.write(f"\n# Python virtual environment\n{venv_path}/\n")
            
            self.print(f"Added '{venv_path}/' to .gitignore", 
                     Fore.GREEN, emoji=Emoji.CHECK, indent=4)
            return
        
        # Create new gitignore file
        gitignore_content = f"""# Python virtual environment
{venv_path}/

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Distribution / packaging
dist/
build/
*.egg-info/

# Unit test / coverage reports
htmlcov/
.coverage
.pytest_cache/

# Jupyter Notebook
.ipynb_checkpoints

# Environment variables
.env
.env.local
"""
        
        try:
            with open(gitignore_path, 'w') as f:
                f.write(gitignore_content)
            self.print(f"Created .gitignore file with '{venv_path}/' entry", 
                     Fore.GREEN, emoji=Emoji.CHECK, indent=2)
        except Exception as e:
            self.print(f"Failed to create .gitignore file: {e}", 
                     Fore.RED, emoji=Emoji.ERROR, indent=2)
    
    def create_vscode_settings(self) -> None:
        """Create VS Code settings for the project"""
        if not self.args.vscode:
            return
            
        venv_path = os.path.abspath(self.venv_name)
        vscode_dir = ".vscode"
        settings_path = os.path.join(vscode_dir, "settings.json")
        
        # Create .vscode directory if needed
        os.makedirs(vscode_dir, exist_ok=True)
        
        # Get Python path for settings
        if platform.system() == "Windows":
            python_path = os.path.join(venv_path, "Scripts", "python.exe").replace("\\", "\\\\")
        else:
            python_path = os.path.join(venv_path, "bin", "python")
        
        # Check if file already exists
        if os.path.exists(settings_path):
            self.print(f"VS Code settings.json already exists, updating", 
                     Fore.YELLOW, emoji=Emoji.WARNING, indent=2)
            
            try:
                with open(settings_path, 'r') as f:
                    settings = json.load(f)
            except Exception as e:
                self.print(f"Failed to read existing settings.json: {e}", 
                         Fore.RED, emoji=Emoji.ERROR, indent=4)
                settings = {}
        else:
            settings = {}
        
        # Update settings
        settings["python.defaultInterpreterPath"] = python_path
        settings["python.terminal.activateEnvironment"] = True
        
        # Add uv-specific settings if needed
        if not self.args.no_uv_settings:
            settings["python.formatting.provider"] = "black"
            settings["python.linting.enabled"] = True
            settings["python.linting.flake8Enabled"] = True
        
        # Save settings
        try:
            with open(settings_path, 'w') as f:
                json.dump(settings, f, indent=4)
            self.print(f"Created/updated VS Code settings for {self.venv_name}", 
                     Fore.GREEN, emoji=Emoji.CHECK, indent=2)
        except Exception as e:
            self.print(f"Failed to create VS Code settings: {e}", 
                     Fore.RED, emoji=Emoji.ERROR, indent=2)
    
    def print_activation_instructions(self) -> None:
        """Print instructions for activating and using the uv environment"""
        venv_name = self.venv_name
        
        self.print("\nuv Virtual Environment Activation Instructions:", 
                 Fore.CYAN, emoji=Emoji.ROCKET)
        
        # Platform-specific activation instructions
        if platform.system() == "Windows":
            # CMD
            cmd_activate = os.path.join(venv_name, "Scripts", "activate.bat")
            self.print("Windows Command Prompt:", Fore.BLUE, indent=2)
            self.print(f"{cmd_activate}", Fore.WHITE, indent=4)
            
            # PowerShell
            ps_activate = os.path.join(venv_name, "Scripts", "Activate.ps1")
            self.print("Windows PowerShell:", Fore.BLUE, indent=2)
            self.print(f".\\{venv_name}\\Scripts\\Activate.ps1", Fore.WHITE, indent=4)
        else:
            # Unix-like (Linux, macOS)
            bash_activate = os.path.join(venv_name, "bin", "activate")
            self.print("Linux/macOS (Bash/Zsh):", Fore.BLUE, indent=2)
            self.print(f"source {bash_activate}", Fore.WHITE, indent=4)
        
        # Deactivation (same for all platforms)
        self.print("\nTo deactivate:", Fore.RED, indent=2)
        self.print("deactivate", Fore.WHITE, indent=4)
        
        # uv-specific package management
        self.print("\nuv Package Management:", Fore.GREEN, emoji=Emoji.PACKAGE, indent=2)
        if platform.system() == "Windows":
            python_path = os.path.join(venv_name, "Scripts", "python.exe")
        else:
            python_path = os.path.join(venv_name, "bin", "python")
            
        self.print("Install package:", Fore.WHITE, indent=4)
        self.print(f"uv pip install --python {python_path} <package-name>", Fore.CYAN, indent=6)
        
        self.print("Install from requirements:", Fore.WHITE, indent=4)
        self.print(f"uv pip install --python {python_path} -r requirements.txt", Fore.CYAN, indent=6)
        
        self.print("Upgrade package:", Fore.WHITE, indent=4)
        self.print(f"uv pip install --python {python_path} --upgrade <package-name>", Fore.CYAN, indent=6)
    
    def print_uv_features(self) -> None:
        """Print information about uv's unique features"""
        self.print("\nuv Special Features:", Fore.MAGENTA, emoji=Emoji.STAR, indent=2)
        self.print("Fast Package Installation: uv is designed for speed", 
                 Fore.WHITE, emoji=Emoji.BOLT, indent=4)
        self.print("Dependency Resolution: uv pip resolve <package-name>", 
                 Fore.WHITE, emoji=Emoji.GEAR, indent=4)
        self.print("Lockfile Generation: uv pip compile requirements.txt -o requirements.lock", 
                 Fore.WHITE, emoji=Emoji.SAVE, indent=4)
        self.print("Smart Cache: uv uses aggressive caching for faster installs", 
                 Fore.WHITE, emoji=Emoji.ROCKET, indent=4)
        self.print("For more information: uv --help", 
                 Fore.WHITE, emoji=Emoji.BOOK, indent=4)
    
    def run(self) -> None:
        """Main execution flow"""
        try:
            # Display banner
            self.header(f"{Emoji.UV} uv Environment Wizard v{__version__} {Emoji.UV}")
            
            # Check uv installation
            if not self.check_uv_installation():
                sys.exit(1)
            
            # Get environment name
            venv_name = self.get_venv_name()
            
            # Get Python version
            python_version = self.get_python_version()
            
            # Create uv environment
            if not self.create_venv(python_version):
                sys.exit(1)
            
            # Create requirements.txt file
            self.create_requirements_file()
            
            # Install packages if requested
            self.install_packages()
            
            # Create gitignore if requested
            self.create_gitignore()
            
            # Create VS Code settings if requested
            self.create_vscode_settings()
            
            # Print activation instructions
            self.print_activation_instructions()
            
            # Print uv-specific features
            self.print_uv_features()
            
            # Final success message
            self.header(f"{Emoji.PARTY} uv environment '{venv_name}' setup complete! {Emoji.PARTY}")
            
        except KeyboardInterrupt:
            self.print("\nOperation canceled by user", Fore.YELLOW, emoji=Emoji.EXIT)
            sys.exit(0)


def parse_args() -> argparse.Namespace:
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="uvWiz: uv Environment Wizard",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    
    # Basic options
    parser.add_argument("-n", "--name", 
                      help="Name of virtual environment to create")
    parser.add_argument("-p", "--python", 
                      help="Python path or command to use (e.g., python3.9, /usr/bin/python3)")
    parser.add_argument("--uv-exe", 
                      help="Path to uv executable (default: 'uv')")
    
    # Environment options
    parser.add_argument("--system-site-packages", action="store_true",
                      help="Give the environment access to system site-packages")
    
    # Requirements options
    parser.add_argument("--no-requirements", action="store_true",
                      help="Don't create requirements.txt file")
    parser.add_argument("--template", choices=["basic", "web", "data", "ai"],
                      help="Requirements template to use")
    parser.add_argument("--pip-install", action="store_true",
                      help="Install packages from requirements.txt")
    parser.add_argument("--no-pip-install", action="store_true",
                      help="Don't install packages from requirements.txt")
    
    # IDE integration
    parser.add_argument("--vscode", action="store_true",
                      help="Create/update VS Code settings")
    parser.add_argument("--no-uv-settings", action="store_true",
                      help="Don't add uv-specific settings to VS Code")
    parser.add_argument("--gitignore", action="store_true",
                      help="Create/update .gitignore file")
    
    # Behavioral options
    parser.add_argument("-f", "--force", action="store_true",
                      help="Force creation (delete existing environment)")
    parser.add_argument("--non-interactive", action="store_true",
                      help="Non-interactive mode (use defaults)")
    
    # UI options
    parser.add_argument("-q", "--quiet", action="store_true",
                      help="Minimal output")
    parser.add_argument("--no-color", action="store_true",
                      help="Disable colored output")
    parser.add_argument("--no-emoji", action="store_true",
                      help="Disable emoji output")
    
    # Version info
    parser.add_argument("--version", action="version",
                      version=f"uvWiz v{__version__}")
    
    return parser.parse_args()


def main() -> None:
    """Main entry point"""
    # Parse arguments
    args = parse_args()
    
    # Create and run wizard
    wizard = UVWizard(args)
    wizard.run()


if __name__ == "__main__":
    main()